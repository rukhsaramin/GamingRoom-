What did I do particularly well?
I think my design of a modular, orderly structure was especially strong. By clearly separating various classes, such as teams, players, and game instances, I was able to apply object-oriented principles. In order to maintain a single point of control for running games and manage game services, I also successfully implemented the Singleton design pattern.

What did I find helpful about the design process?
I was able to plan the architecture before any coding started by going over the design document. Potential difficulties were easier to anticipate after use cases, domain models, and constraints were mapped out. It helped me think more critically about scalability and user needs and provided me with a structured blueprint to follow.

What would I revise or improve?
I would concentrate more on the constraint analysis section if I could only make one revision. If there were a large increase in players, I would take more time to find any possible scaling problems and performance snags. The overall design would be strengthened by improving the scalability analysis.

How did I interpret the user's needs?
I interpreted the needs of the user by emphasizing ease of use, dependability, and rapid scalability. The users required a system that would prevent game rooms from interfering with one another, even when usage was high. Keeping user experience at the forefront of my design choices, I gave priority to autonomous game instances, simple team management, and quick access to join or create games.

Why is it important to consider user needs?
Knowing the needs of the user guarantees that the software will be useful, dependable, and pleasurable to use in the real world. In addition to meeting project requirements, addressing these needs enhances system performance and user satisfaction.

How did I approach designing the software?
I used modular architecture, object-oriented design, and design patterns like iterator and singleton to approach the project. I would keep employing these tactics in the future, but I would also include performance scaling methods and previous risk assessments from the early stages of design.
